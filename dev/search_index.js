var documenterSearchIndex = {"docs":
[{"location":"map_manipulation/","page":"Map Manipulation","title":"Map Manipulation","text":"CurrentModule = Pixell","category":"page"},{"location":"map_manipulation/#Working-with-Maps","page":"Map Manipulation","title":"Working with Maps","text":"","category":"section"},{"location":"map_manipulation/#Plotting","page":"Map Manipulation","title":"Plotting","text":"","category":"section"},{"location":"map_manipulation/","page":"Map Manipulation","title":"Map Manipulation","text":"We provide a simple plot recipe for displaying Enmap with Plots.jl. This package supports multiple backends: if you're using the default GR backend (i.e. by calling using Plots; gr()), then you can set the usual LaTeX font with","category":"page"},{"location":"map_manipulation/","page":"Map Manipulation","title":"Map Manipulation","text":"using Plots\ndefault(fontfamily=\"Computer Modern\", dpi=200)","category":"page"},{"location":"map_manipulation/","page":"Map Manipulation","title":"Map Manipulation","text":"The PyPlot backend uses matplotlib. If you're using this, i.e. using using Plots; pyplot(), then we recommend these settings,","category":"page"},{"location":"map_manipulation/","page":"Map Manipulation","title":"Map Manipulation","text":"using Plots\ndefault(left_margin=15Plots.PlotMeasures.mm, dpi=200)\nPlots.pyrcparams[\"text.usetex\"] = true\nPlots.pyrcparams[\"font.family\"] = \"serif\"\nPlots.pyrcparams[\"mathtext.fontset\"] = \"cm\"","category":"page"},{"location":"map_manipulation/","page":"Map Manipulation","title":"Map Manipulation","text":"Finally, you can eschew our plot recipe completely and use PyPlot.jl to have a classic matplotlib experience. ","category":"page"},{"location":"map_manipulation/#Map-Manipulation","page":"Map Manipulation","title":"Map Manipulation","text":"","category":"section"},{"location":"map_manipulation/","page":"Map Manipulation","title":"Map Manipulation","text":"box = [10   -10;           # RA\n       -5     5] * degree  # DEC\nshape, wcs = geometry(Pixell.WCS.WCSTransform, box, 1 * degree)","category":"page"},{"location":"map_manipulation/#Relating-pixels-to-the-sky","page":"Map Manipulation","title":"Relating pixels to the sky","text":"","category":"section"},{"location":"map_manipulation/","page":"Map Manipulation","title":"Map Manipulation","text":"Unlike the Python version, Pixell.jl always has right ascension in the first dimension, and  declination in the second. That is, (RA DEC) order, or (horizontal, vertical). ","category":"page"},{"location":"map_manipulation/","page":"Map Manipulation","title":"Map Manipulation","text":"#                                   RA   DEC\npixRA, pixDEC = sky2pix(shape, wcs, 0.0, 0.0)","category":"page"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Pixell]","category":"page"},{"location":"api/#Pixell.AbstractDT","page":"API","title":"Pixell.AbstractDT","text":"Distance Transform (DT), especially Spherical Distance Transforms (SDT)\n\n\n\n\n\n","category":"type"},{"location":"api/#Pixell.CarClenshawCurtis","page":"API","title":"Pixell.CarClenshawCurtis","text":"Fast custom WCS structure.\n\n\n\n\n\n","category":"type"},{"location":"api/#Pixell.Enmap","page":"API","title":"Pixell.Enmap","text":"Map type, contains an AbstractArray and a WCS object, but behaves like the AbstractArray it contains for array operations. It only implements the subset of Base.Array operations which are common on maps. You should work with the data directly using enmap_instance.data if you need additional Array functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#Healpix.alm2map-Tuple{Alm, Any, WCS.AbstractWCSTransform}","page":"API","title":"Healpix.alm2map","text":"perform inverse SHT of an intensity map\n\n\n\n\n\n","category":"method"},{"location":"api/#Healpix.map2alm-Union{Tuple{Enmap{T, 2}}, Tuple{T}} where T","page":"API","title":"Healpix.map2alm","text":"perform forward SHT of an intensity map\n\n\n\n\n\n","category":"method"},{"location":"api/#Pixell.create_sht_band-Tuple{Enmap}","page":"API","title":"Pixell.create_sht_band","text":"Complete rings for spherical harmonic transforms. Also converts to AbstractArray{Float64,2}.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pixell.distance_transform-Tuple{BruteForceSDT, Enmap}","page":"API","title":"Pixell.distance_transform","text":"Brute-force spherical distance transform. ~ O(Nₚᵢₓ × N₀). Doesn't handle wrapping.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pixell.distance_transform-Tuple{ExactSeqSDT, Enmap}","page":"API","title":"Pixell.distance_transform","text":"Compute an exact distance transform ~ O(Nₚᵢₓ), based on Mullikin 1992 and Danielsson 1980\n\n\n\n\n\n","category":"method"},{"location":"api/#Pixell.dplanck","page":"API","title":"Pixell.dplanck","text":"The derivative of the planck spectrum with respect to temperature, evaluated at frequencies f and temperature T, in units of Jy/sr/K.\n\nA blackbody has intensity I = 2hf^3c^2(exphfkT-1) = V(expx-1) with V = 2hf^3c^2, x = hfkT. dIdx = -V(expx-1)^2 * expx dIdT = dIdx * dxdT = 2hf^3c^2(expx-1)^2*expx * hfk  T^2 = 2*h^2*f^4c^2kT^2 * expx(expx-1)^2 = 2*x^4 * k^3*T^2(h^2*c^2) * expx(expx-1)^2 =  (4*sinh(x2)^2)\n\n\n\n\n\n","category":"function"},{"location":"api/#Pixell.first_last_rings_in_fullsky-Tuple{Any, WCS.AbstractWCSTransform}","page":"API","title":"Pixell.first_last_rings_in_fullsky","text":"Get index of ring given angle\n\n\n\n\n\n","category":"method"},{"location":"api/#Pixell.fullringnum-Tuple{WCS.AbstractWCSTransform}","page":"API","title":"Pixell.fullringnum","text":"Number of rings in a fullsky version of this WCS.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pixell.fullringsize-Tuple{WCS.AbstractWCSTransform}","page":"API","title":"Pixell.fullringsize","text":"Number of pixels in full CAR ring of this WCS.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pixell.fullsky_geometry-Tuple{Type{<:WCS.AbstractWCSTransform}, Any}","page":"API","title":"Pixell.fullsky_geometry","text":"fullsky_geometry([W=CarClenshawCurtis], res; shape = nothing, dims = ())\n\nGenerates a full-sky geometry.\n\nArguments:\n\nproj=CarClenshawCurtis(): [optional] projection\nres: resolution in radians. Passing a Number produces a square pixel.\n\nPassing a tuple with (ΔRA, ΔDEC) produces a rectangular pixel.\n\nKeywords\n\nshape::NTuple=nothing: shape of the map. If not specified, will be computed.\ndims::NTuple=(): additional dimensions to append to the shape, such as (3,) for IQU\n\nto generate a map with (nx, ny, 3).\n\nReturns:\n\nshape::Tuple, wcs::W: a tuple containing the shape of the map and the WCS\n\nExamples\n\njulia> shape, wcs = fullsky_geometry(deg2rad(30/60))  # 30 arcmin pixel\n((720, 361), WCSTransform(naxis=2,cdelt=[-0.5, 0.5],crval=[0.25, 0.0],crpix=[360.5, 181.0]))\n\n\n\n\n\n","category":"method"},{"location":"api/#Pixell.getlmax-Tuple{Any}","page":"API","title":"Pixell.getlmax","text":"Generate an estimate of the Nyquist frequency for a map\n\n\n\n\n\n","category":"method"},{"location":"api/#Pixell.iscyl-Tuple{WCS.WCSTransform}","page":"API","title":"Pixell.iscyl","text":"Check if a WCS is a cylindrical pixelization\n\n\n\n\n\n","category":"method"},{"location":"api/#Pixell.make_cc_geom_info-Tuple{Any, WCS.AbstractWCSTransform}","page":"API","title":"Pixell.make_cc_geom_info","text":"Clenshaw-Curtis quadrature weights, make a Libsharp GeomInfo\n\n\n\n\n\n","category":"method"},{"location":"api/#Pixell.metric-Tuple{Pixell.AbstractSDT, Any, Any, Any, Any}","page":"API","title":"Pixell.metric","text":"Metric on the sphere for RA (α) and DEC (δ)\n\n\n\n\n\n","category":"method"},{"location":"api/#Pixell.pix2sky","page":"API","title":"Pixell.pix2sky","text":"pix2sky(m::Enmap, pixcoords)\n\nConvert 1-indexed pixels to sky coordinates. The output sky coordinates are determined by WCS, but usually are in units of degrees. \n\nArguments:\n\nm::Enmap: the map that provides a coordinate system\npixcoords: pixcoords should be a 2-d array where \"pixcoords[:, i]\" is the i-th set of coordinates,    or a 1-d array representing a single set of coordinates. \n\nReturns:\n\nArray: same shape as pixcoords\n\nExamples\n\njulia> shape, wcs = fullsky_geometry(deg2rad(1))\njulia> pix2sky(shape, wcs [1.0, 1.0])\n2-element Vector{Float64}:\n 180.0\n -90.0\n\n\n\n\n\n","category":"function"},{"location":"api/#Pixell.pix2sky!-Union{Tuple{TS}, Tuple{TP}, Tuple{Any, CarClenshawCurtis, AbstractMatrix{TP}, AbstractMatrix{TS}}} where {TP, TS}","page":"API","title":"Pixell.pix2sky!","text":"pix2sky!(m::Enmap, pixcoords, skycoords)\n\nConvert 1-indexed pixels to sky coordinates, in-place. The output sky coordinates are  determined by WCS, but usually are in units of degrees. \n\nArguments:\n\nm::Enmap: the map that provides a coordinate system\npixcoords: pixel coordinates should be a 2-d array where \"pixcoords[:, i]\" is the i-th    set of coordinates, or a 1-d array representing a single set of coordinates. \nskycoords: output array for sky coordinates, must be same same as pixcoords\n\nReturns:\n\nArray: skycoords\n\nExamples\n\njulia> shape, wcs = fullsky_geometry(deg2rad(1))\n       pixcoords =  100 .* rand(2,4096 * 2)\n       skycoords =  similar(pixcoords)\n\njulia> pix2sky!(shape, wcs, pixcoords, skycoords)\n\n\n\n\n\n","category":"method"},{"location":"api/#Pixell.pix2sky-Tuple{Any, CarClenshawCurtis, Any, Any}","page":"API","title":"Pixell.pix2sky","text":"pix2sky(m::Enmap{T,N,AA,<:CarClenshawCurtis}, ra_pixel, dec_pixel)\n\nCompute the sky position of a single position on the sky.\n\nOnly implemented for CAR (Clenshaw-Curtis variant) projections, so the input map is of type Enmap{T,N,AA,<:CarClenshawCurtis}. This takes pixel indices for RA and DEC, and returns a tuple containing the corresponding RA and DEC.\n\nExamples\n\njulia> shape, wcs = fullsky_geometry(deg2rad(1))\njulia> pix2sky(shape, wcs, 30.0, 80.0)\n(151.0, -11.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#Pixell.pixareamap!-Tuple{Enmap}","page":"API","title":"Pixell.pixareamap!","text":"In-place write to pixels the areas of those pixels in steradians.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pixell.pixareamap-Union{Tuple{Enmap{T, N, AA, W}}, Tuple{W}, Tuple{AA}, Tuple{N}, Tuple{T}} where {T, N, AA, W<:CarClenshawCurtis}","page":"API","title":"Pixell.pixareamap","text":"Generate a similar Enmap whose pixel values are the areas of the pixels in steradians.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pixell.rewind-Tuple{Any}","page":"API","title":"Pixell.rewind","text":"rewind(angles, period=2π, ref_angle=0)\n\nGiven angles or other cyclic coordinates with the specified period, such that the angle + period has the same meaning as the original angle, this function adds or subtracts  multiples of the period such that the result has the same meaning, but now all angles lie in an interval of length the specified period, centered on the reference angle ref_angle.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pixell.sky2pix","page":"API","title":"Pixell.sky2pix","text":"sky2pix(m::Enmap, skycoords)\n\nConvert sky coordinates to 1-indexed pixels. The input sky coordinates are determined by WCS, but usually are in units of degrees. \n\nArguments:\n\nm::Enmap: the map to obtain the coordinates from\nskycoords: skycoords should be a 2-d array where \"skycoords[:, i]\" is the i-th set of coordinates,    or a 1-d array representing a single set of coordinates. \n\nReturns:\n\nArray: same shape as skycoords\n\nExamples\n\njulia> shape, wcs = fullsky_geometry(deg2rad(1))\njulia> sky2pix(shape, wcs, [30.0, 50.0])\n2-element Vector{Float64}:\n 151.0\n 141.0\n\n\n\n\n\n","category":"function"},{"location":"api/#Pixell.sky2pix!-Union{Tuple{TP}, Tuple{TS}, Tuple{Any, CarClenshawCurtis, AbstractMatrix{TS}, AbstractMatrix{TP}}} where {TS, TP}","page":"API","title":"Pixell.sky2pix!","text":"sky2pix!(m::Enmap, skycoords, pixcoords)\n\nConvert sky coordinates to 1-indexed pixels, in-place. The input sky coordinates are  determined by WCS, but usually are in units of degrees. \n\nArguments:\n\nm::Enmap: the map that provides a coordinate system\nskycoords: sky coordinates should be a 2-d array where \"skycoords[:, i]\" is the i-th    set of coordinates, or a 1-d array representing a single set of coordinates. \npixcoords: output array for pixel coordinates, must be same same as pixcoords\n\nReturns:\n\nArray: pixcoords\n\nExamples\n\njulia> shape, wcs = fullsky_geometry(deg2rad(1))\n       skycoords =  similar(pixcoords)\n       pixcoords =  100 .* rand(2,4096 * 2)\njulia> sky2pix!(shape, wcs, skycoords, pixcoords)\n\n\n\n\n\n","category":"method"},{"location":"api/#Pixell.sky2pix-Tuple{Any, CarClenshawCurtis, Number, Number}","page":"API","title":"Pixell.sky2pix","text":"sky2pix(m::Enmap{T,N,AA,<:CarClenshawCurtis}, ra, dec)\n\nCompute 1-indexed pixels into sky coordinates.\n\nOnly implemented for CAR (Clenshaw-Curtis variant) projections. Takes  RA and DEC and returns a tuple containing the corresponding pixel indices. If vectors of RA and DEC are given, then vectors of  pixel indices will be returned.\n\nExamples\n\njulia> shape, wcs = fullsky_geometry(deg2rad(1))\njulia> sky2pix(shape, wcs, 30.0, 80.0)\n(151.0, 171.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#Pixell.skyarea-Tuple{Any, WCS.WCSTransform}","page":"API","title":"Pixell.skyarea","text":"Area of a patch given shape and WCS, in steradians.\n\n\n\n\n\n","category":"method"},{"location":"developer_notes/","page":"Developer Notes","title":"Developer Notes","text":"CurrentModule = Pixell","category":"page"},{"location":"developer_notes/#Developer-Notes","page":"Developer Notes","title":"Developer Notes","text":"","category":"section"},{"location":"developer_notes/","page":"Developer Notes","title":"Developer Notes","text":"If you're new to the Julia language, my favorite tutorial is this Introduction to Julia for Quantitative Economics. Sections 1-13 are the most relevant if you are an astronomer, but some of later numerical techniques can also be useful. Computing clusters will often have a Julia module; make sure you load a Julia version 1.6 or later. ","category":"page"},{"location":"developer_notes/","page":"Developer Notes","title":"Developer Notes","text":"For your development computer, download the precompiled binaries and add the Julia executable to your $PATH. Do not use a package manager to install Julia. The Julia compiler has a heavily modified glibc, which many package managers misconfigure (such as the AUR). This problem is also faced by Rust.","category":"page"},{"location":"developer_notes/#Package-development","page":"Developer Notes","title":"Package development","text":"","category":"section"},{"location":"developer_notes/","page":"Developer Notes","title":"Developer Notes","text":"To make changes to this package, start up the Julia interpeter and run","category":"page"},{"location":"developer_notes/","page":"Developer Notes","title":"Developer Notes","text":"julia> ] dev git@github.com:simonsobs/Pixell.jl.git","category":"page"},{"location":"developer_notes/","page":"Developer Notes","title":"Developer Notes","text":"By default, this will place a copy of this package's repository in your home directory, ~/.julia/dev/Pixell. Changes to the code in this folder will be reflected in your global environment.","category":"page"},{"location":"developer_notes/","page":"Developer Notes","title":"Developer Notes","text":"It can be helpful to write documentation alongside a live preview. This is accomplished with the LiveServer package. If you have a standard Julia installlation, you can run from the command line,","category":"page"},{"location":"developer_notes/","page":"Developer Notes","title":"Developer Notes","text":"cd $HOME/.julia/dev/Pixell\njulia --project=. -e \"using Pixell, LiveServer; servedocs()\"","category":"page"},{"location":"developer_notes/","page":"Developer Notes","title":"Developer Notes","text":"This will render HTML pages and provide an HTTP server for local previews. The documentation will automatically update when you make changes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Pixell","category":"page"},{"location":"#Pixell.jl","page":"Home","title":"Pixell.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pixell is a package for high performance data analysis of sky maps with rectangular pixels. It is based on a subset of the Python package pixell. This package has a particular focus on astrophysical and cosmological science enabled by efficient map manipulation, easy multithreading and GPU support, and machine learning. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package manipulates maps on equidistant cylindrical projections (ECP) like plate carrée. It implements an array type equipped with WCS information. Another common pixelization of the sphere is Healpix.jl, which uses a constant size pixel with a more complicated pixel shape. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pixell supports development and deployment on a wide variety of platforms, ranging from laptops to computing clusters. Installation is as simple as starting up the Julia interpreter, and running","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ] add Pixell","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"CurrentModule = Pixell","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's make an Enmap, the primary structure in this package.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Pixell, Plots\nshape, wcs = fullsky_geometry(300.0 * Pixell.arcminute)  # set up the map geometry\nm = Enmap(randn(shape), wcs)  # generate a random map with the shape and WCS\nplot(m)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's compute a spherical harmonic transform with Libsharp, and then compute the power spectrum C_ell.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"cl = alm2cl(map2alm(m))\nplot(cl, ylabel=raw\"$C_{\\ell}$\", xlabel=raw\"Multipole moment, $\\ell$\")","category":"page"},{"location":"tutorial/#Reading-and-writing-maps","page":"Tutorial","title":"Reading and writing maps","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"m = read_map(\"map.fits\")","category":"page"},{"location":"tutorial/#Noteworthy-differences-from-Python","page":"Tutorial","title":"Noteworthy differences from Python","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The Julia language has a number of differences from Python, and the Pixell.jl has a number of important differences from the Python package pixell.","category":"page"}]
}
